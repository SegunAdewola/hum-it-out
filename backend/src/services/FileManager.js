const fs = require('fs').promises;
const path = require('path');
const archiver = require('archiver');
const config = require('../config/environment');
const logger = require('../utils/logger');

class FileManager {
  constructor() {
    this.outputDir = config.storage.local.generatedDir;
    this.uploadsDir = config.storage.local.uploadsDir;
    this.tempDir = config.storage.local.tempDir;
    
    // Ensure directories exist
    this.ensureDirectories();
  }

  async ensureDirectories() {
    try {
      await fs.mkdir(this.outputDir, { recursive: true });
      await fs.mkdir(this.uploadsDir, { recursive: true });
      await fs.mkdir(this.tempDir, { recursive: true });
      await fs.mkdir(path.join(this.outputDir, 'stems'), { recursive: true });
    } catch (error) {
      logger.error('Failed to create directories:', error);
    }
  }

  async generateAudioFiles(sessionId, musicData) {
    const sessionDir = path.join(this.outputDir, sessionId);
    await fs.mkdir(sessionDir, { recursive: true });

    const results = {
      backingTrack: null,
      stems: {},
      midi: null,
      lyrics: null,
      metadata: null,
      downloadPackage: null,
      totalSize: 0
    };

    try {
      // Generate metadata file first
      results.metadata = await this.createMetadataFile(sessionDir, musicData);
      
      // Generate lyrics file
      if (musicData.lyrics) {
        results.lyrics = await this.createLyricsFile(sessionDir, musicData.lyrics);
      }
      
      // Generate MIDI file
      results.midi = await this.generateMIDI(sessionDir, musicData);
      
      // Generate audio stems (simplified version for demo)
      results.stems = await this.generateDemoStems(sessionDir, musicData);
      
      // Create backing track (mix of stems)
      results.backingTrack = await this.createDemoBackingTrack(sessionDir, musicData);
      
      // Create download package (ZIP)
      results.downloadPackage = await this.createDownloadPackage(sessionId, results);
      
      // Calculate total size
      results.totalSize = await this.calculateTotalSize(results);
      
      logger.info('Audio files generated successfully:', {
        sessionId,
        totalSize: results.totalSize,
        filesGenerated: Object.keys(results).length
      });
      
      return results;

    } catch (error) {
      logger.error('Audio file generation failed:', error);
      // Cleanup on error
      await this.cleanupFiles(sessionDir);
      throw error;
    }
  }

  async createMetadataFile(sessionDir, musicData) {
    const metadata = {
      generatedAt: new Date().toISOString(),
      version: '1.0.0',
      generator: 'Hum It Out v1.0',
      musicData: {
        tempo: musicData.analysis?.tempo || 120,
        key: musicData.analysis?.key || 'C',
        mood: musicData.analysis?.mood || ['neutral'],
        genres: musicData.analysis?.genres || ['pop'],
        chordProgression: musicData.chords?.primaryProgression || ['C', 'Am', 'F', 'G'],
        structure: musicData.arrangement?.structure || ['intro', 'verse', 'chorus', 'outro']
      },
      files: {
        backingTrack: 'backing-track.wav',
        midi: 'session.mid',
        lyrics: 'lyrics.txt',
        stems: {
          drums: 'stems/drums.wav',
          bass: 'stems/bass.wav',
          chords: 'stems/chords-piano.wav',
          melody: 'stems/melody-guide.wav'
        }
      },
      usage: {
        daw_compatible: ['GarageBand', 'Logic Pro', 'Ableton Live', 'FL Studio', 'Pro Tools'],
        file_formats: ['WAV (48kHz/24-bit)', 'MIDI', 'TXT'],
        ready_for: 'immediate import and production'
      }
    };

    const metadataPath = path.join(sessionDir, 'metadata.json');
    await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2));
    
    return metadataPath;
  }

  async createLyricsFile(sessionDir, lyrics) {
    const lyricsContent = `Hum It Out - Generated Lyrics
=====================================

Generated: ${new Date().toLocaleDateString()}

Transcribed Lyrics:
-------------------
${lyrics}

Usage Instructions:
-------------------
• Use as reference for vocal recording
• Modify and expand as needed
• Import timing from MIDI file
• Sync with backing track for recording

Generated by Hum It Out
Voice to Music AI System
`;

    const lyricsPath = path.join(sessionDir, 'lyrics.txt');
    await fs.writeFile(lyricsPath, lyricsContent);
    
    return lyricsPath;
  }

  async generateMIDI(sessionDir, musicData) {
    // For demo purposes, create a simple MIDI-like file
    // In production, you'd use a proper MIDI library
    const midiData = {
      format: 'MIDI-like JSON',
      ticksPerQuarter: 480,
      tempo: musicData.analysis?.tempo || 120,
      key: musicData.analysis?.key || 'C',
      tracks: [
        {
          name: 'Chords',
          channel: 0,
          notes: this.generateChordNotes(musicData.chords?.primaryProgression || ['C', 'Am', 'F', 'G'])
        },
        {
          name: 'Melody Guide',
          channel: 1,
          notes: this.generateMelodyNotes(musicData.analysis?.key || 'C')
        },
        {
          name: 'Drums',
          channel: 9,
          notes: this.generateDrumPattern()
        }
      ]
    };

    const midiPath = path.join(sessionDir, 'session.mid');
    
    // For demo, save as JSON (in production, use proper MIDI format)
    await fs.writeFile(midiPath + '.json', JSON.stringify(midiData, null, 2));
    
    // Create a simple text representation for now
    const midiText = `MIDI File Generated by Hum It Out
=====================================

Format: Standard MIDI File
Tempo: ${midiData.tempo} BPM
Key: ${midiData.key}
Tracks: ${midiData.tracks.length}

Track List:
${midiData.tracks.map((track, i) => `  ${i + 1}. ${track.name} (Channel ${track.channel})`).join('\n')}

Instructions:
• Import into your favorite DAW
• All tracks are tempo-locked
• Adjust instruments as needed
• Use as foundation for your song

Generated: ${new Date().toISOString()}
`;

    await fs.writeFile(midiPath, midiText);
    return midiPath;
  }

  generateChordNotes(chordProgression) {
    const chordNotes = {
      'C': [60, 64, 67],   // C-E-G
      'Am': [57, 60, 64],  // A-C-E  
      'F': [53, 57, 60],   // F-A-C
      'G': [55, 59, 62]    // G-B-D
    };

    const notes = [];
    let time = 0;
    
    chordProgression.forEach(chord => {
      const midiNotes = chordNotes[chord] || chordNotes['C'];
      midiNotes.forEach(note => {
        notes.push({
          note: note,
          velocity: 80,
          time: time,
          duration: 1920 // Full measure
        });
      });
      time += 1920; // Move to next measure
    });

    return notes;
  }

  generateMelodyNotes(key) {
    // Simple melody in the given key
    const scales = {
      'C': [60, 62, 64, 65, 67, 69, 71],
      'G': [67, 69, 71, 72, 74, 76, 78],
      'Am': [57, 59, 60, 62, 64, 65, 67]
    };

    const scale = scales[key] || scales['C'];
    const melody = [];
    let time = 0;

    // Generate a simple melody
    for (let i = 0; i < 16; i++) {
      const noteIndex = Math.floor(Math.random() * scale.length);
      melody.push({
        note: scale[noteIndex],
        velocity: 70,
        time: time,
        duration: 480
      });
      time += 480;
    }

    return melody;
  }

  generateDrumPattern() {
    // Simple drum pattern
    const drums = [];
    const kick = 36;
    const snare = 38;
    const hihat = 42;

    for (let measure = 0; measure < 4; measure++) {
      const baseTime = measure * 1920;
      
      // Kick on 1 and 3
      drums.push({ note: kick, velocity: 100, time: baseTime, duration: 240 });
      drums.push({ note: kick, velocity: 90, time: baseTime + 960, duration: 240 });
      
      // Snare on 2 and 4  
      drums.push({ note: snare, velocity: 95, time: baseTime + 480, duration: 240 });
      drums.push({ note: snare, velocity: 95, time: baseTime + 1440, duration: 240 });
      
      // Hi-hat on all eighth notes
      for (let i = 0; i < 8; i++) {
        drums.push({ note: hihat, velocity: 60, time: baseTime + (i * 240), duration: 120 });
      }
    }

    return drums;
  }

  async generateDemoStems(sessionDir, musicData) {
    const stemsDir = path.join(sessionDir, 'stems');
    await fs.mkdir(stemsDir, { recursive: true });

    // For demo purposes, create placeholder audio files
    // In production, these would be real audio files generated by Tone.js
    
    const stems = {};
    const stemTypes = ['drums', 'bass', 'chords-piano', 'melody-guide'];
    
    for (const stemType of stemTypes) {
      const stemPath = path.join(stemsDir, `${stemType}.wav`);
      
      // Create demo content for each stem
      const demoContent = this.createDemoAudioContent(stemType, musicData);
      await fs.writeFile(stemPath, demoContent);
      
      stems[stemType] = stemPath;
    }

    return stems;
  }

  createDemoAudioContent(stemType, musicData) {
    const tempo = musicData.analysis?.tempo || 120;
    const key = musicData.analysis?.key || 'C';
    
    // Create text content representing what the audio would contain
    return `Hum It Out - ${stemType} Track
=====================================

Demo Audio File (Text Representation)
In production, this would be a real WAV file.

Track: ${stemType}
Tempo: ${tempo} BPM
Key: ${key}
Duration: ~30 seconds
Format: WAV (48kHz/24-bit stereo)

Content:
${this.getTrackDescription(stemType, musicData)}

To play this track:
1. Replace this file with real audio generated by Tone.js
2. Import into your DAW
3. Adjust levels and effects as needed

Generated: ${new Date().toISOString()}
`;
  }

  getTrackDescription(stemType, musicData) {
    const descriptions = {
      'drums': `• Kick on beats 1 and 3
• Snare on beats 2 and 4  
• Hi-hat eighth notes
• Tempo: ${musicData.analysis?.tempo || 120} BPM`,
      
      'bass': `• Root notes of chord progression
• ${(musicData.chords?.primaryProgression || ['C', 'Am', 'F', 'G']).join(' - ')}
• Walking bass line pattern
• Synced to drums`,
      
      'chords-piano': `• Piano chord progression
• Chords: ${(musicData.chords?.primaryProgression || ['C', 'Am', 'F', 'G']).join(' - ')}
• Key: ${musicData.analysis?.key || 'C'}
• Whole note rhythm`,
      
      'melody-guide': `• Clean melody line from hummed input
• Quantized to ${musicData.analysis?.key || 'C'} scale
• Guide for vocal recording
• Tempo-locked to backing track`
    };

    return descriptions[stemType] || 'Audio content description';
  }

  async createDemoBackingTrack(sessionDir, musicData) {
    const backingTrackPath = path.join(sessionDir, 'backing-track.wav');
    
    const backingTrackContent = `Hum It Out - Full Backing Track
========================================

Demo Mixed Track (Text Representation)
In production, this would be a mixed WAV file.

Track Details:
• Tempo: ${musicData.analysis?.tempo || 120} BPM
• Key: ${musicData.analysis?.key || 'C'}
• Duration: ~30 seconds
• Format: WAV (48kHz/24-bit stereo)

Mix Contains:
• Drums (level: 85%)
• Bass (level: 75%)
• Piano chords (level: 60%)
• Melody guide (level: 90%)

Chord Progression:
${(musicData.chords?.primaryProgression || ['C', 'Am', 'F', 'G']).join(' - ')}

Usage:
• Import into DAW for immediate playback
• Use as backing for live performance
• Reference for vocal recording
• Foundation for further production

Generated: ${new Date().toISOString()}
`;

    await fs.writeFile(backingTrackPath, backingTrackContent);
    return backingTrackPath;
  }

  async createDownloadPackage(sessionId, files) {
    const packagePath = path.join(this.outputDir, `${sessionId}_package.zip`);
    
    return new Promise((resolve, reject) => {
      const output = require('fs').createWriteStream(packagePath);
      const archive = archiver('zip', { zlib: { level: 9 } });

      output.on('close', () => {
        logger.info('Download package created:', {
          sessionId,
          size: archive.pointer(),
          path: packagePath
        });
        resolve(packagePath);
      });

      archive.on('error', (err) => {
        logger.error('Archive creation failed:', err);
        reject(err);
      });

      archive.pipe(output);

      // Add all files to the archive
      Object.entries(files).forEach(([key, filePath]) => {
        if (filePath && key !== 'downloadPackage' && key !== 'totalSize') {
          if (key === 'stems' && typeof filePath === 'object') {
            // Add stems folder
            Object.entries(filePath).forEach(([stemName, stemPath]) => {
              if (require('fs').existsSync(stemPath)) {
                archive.file(stemPath, { name: `stems/${path.basename(stemPath)}` });
              }
            });
          } else if (require('fs').existsSync(filePath)) {
            archive.file(filePath, { name: path.basename(filePath) });
          }
        }
      });

      // Add README
      const readme = `Hum It Out - Generated Music Package
==========================================

Thank you for using Hum It Out!

This package contains all your generated music files:

📁 Files Included:
• backing-track.wav - Full mixed track ready to play
• session.mid - MIDI file for DAW import  
• lyrics.txt - Transcribed lyrics and notes
• metadata.json - Technical details and settings
• stems/ - Individual track files for mixing
  • drums.wav
  • bass.wav  
  • chords-piano.wav
  • melody-guide.wav

🎚️ DAW Import Instructions:
1. Extract all files to a folder
2. Open your DAW (GarageBand, Logic Pro, Ableton, etc.)
3. Import backing-track.wav for immediate playback
4. Import session.mid for full MIDI editing
5. Import individual stems for advanced mixing

🎵 Usage Tips:
• All files are tempo-locked and will sync automatically
• Use melody-guide.wav as reference for vocal recording
• Chord progression and key info in metadata.json
• Stems are separated for professional mixing

🔧 Technical Specs:
• Audio Format: WAV (48kHz/24-bit)
• MIDI Format: Standard MIDI File
• Generated: ${new Date().toLocaleDateString()}

Happy music making!
- Hum It Out Team

🌐 Need help? Visit: humitout.com/support
`;

      archive.append(readme, { name: 'README.txt' });
      archive.finalize();
    });
  }

  async calculateTotalSize(files) {
    let totalSize = 0;
    
    for (const [key, filePath] of Object.entries(files)) {
      if (key === 'totalSize') continue;
      
      try {
        if (key === 'stems' && typeof filePath === 'object') {
          for (const stemPath of Object.values(filePath)) {
            const stats = await fs.stat(stemPath);
            totalSize += stats.size;
          }
        } else if (filePath && typeof filePath === 'string') {
          const stats = await fs.stat(filePath);
          totalSize += stats.size;
        }
      } catch (error) {
        // File might not exist, skip
      }
    }
    
    return totalSize;
  }

  async cleanupFiles(directory) {
    try {
      await fs.rm(directory, { recursive: true, force: true });
      logger.info('Cleaned up files:', { directory });
    } catch (error) {
      logger.warn('Cleanup failed:', { directory, error: error.message });
    }
  }

  async cleanupExpiredFiles(retentionDays = 30) {
    try {
      const files = await fs.readdir(this.outputDir, { withFileTypes: true });
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - retentionDays);

      let cleanedCount = 0;
      for (const file of files) {
        if (file.isDirectory()) {
          const filePath = path.join(this.outputDir, file.name);
          const stats = await fs.stat(filePath);
          
          if (stats.mtime < cutoffDate) {
            await this.cleanupFiles(filePath);
            cleanedCount++;
          }
        }
      }

      logger.info('Expired files cleanup completed:', {
        cleanedCount,
        retentionDays
      });

      return cleanedCount;
    } catch (error) {
      logger.error('Expired files cleanup failed:', error);
      throw error;
    }
  }
}

module.exports = FileManager;
